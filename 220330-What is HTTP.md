# Internet

### 2022.03.30 What is Http?

#### What is HTTP?

<br>

##### 참고한 사이트

> https://developer.mozilla.org/ko/docs/Web/HTTP/Overview
>
> https://www.zerocho.com/category/HTTP/post/5b344f3af94472001b17f2da
>
> https://blog.naver.com/PostView.naver?blogId=allstar927&logNo=90161809512
>
> https://victorydntmd.tistory.com/286

<br>

##### HTTP 란?

- Hyper Text Transfer Protocol
- HyperText 링크를 사용하는 웹페이지를 로드하는데 사용
- 클라이언트-서버 프로토콜
- html, css, js, img와 같은 파일들은 주고 받는 컨텐츠이고, 이를 주고받기 위해서는 서버와 클라이언트가 서로가 알아들을 수 있는 공통의 약속인 메시지가 필요한데 여기서 메시지가 HTTP이다.

<br>

##### HTTP 요청

웹 브라우저가 웹사이트를 로드하는 데 필요한 정보를 요청하는 방식

1. HTTP 버전 유형
2. URL
3. HTTP 메서드
4. HTTP 요청 헤더
5. (HTTP 본문)

<br>

##### HTTP 메서드

서버에서 예상하는 작업을 나타낸다.

- GET(조회)
  - URI 형식으로 특정 리소스를 요청
  - 데이터를 받기만 한다.
- POST(삽입)
  - 특정 리소스에 엔티티를 제출할 때
  - 클라이언트에서 서버로 전달하고자 하는 정보를 서버로 보낸다.
- PUT(수정)
  - 내용 갱신
  - 해당 자원 전체 수정
  - POST처럼 정보를 서버로 제출하는 것으로 형식은 동일하나 갱신 위주로 사용된다.
- PATCH
  - 리소스의 부분만을 수정할 때
- DELETE(삭제)
  - 특정 리소스를 삭제
- OPTIONS, HEAD, TRACE, CONNECT

<br>

##### HTTP 요청 헤더

- 키-값 쌍에 저장된 텍스트 정보

- 클라이언트가 어떤 브라우저를 사용하고 있으며 어떤 데이터가 요청되고 있는지와 같은 핵심 정보를 전달

  ![image](https://user-images.githubusercontent.com/77482972/160685529-e3c01086-8379-4d37-a1ec-5248c68d82de.png)

![image](https://user-images.githubusercontent.com/77482972/160677465-0bdd7bc1-b545-4c67-8333-39d868ea148c.png)

- Request Line : HTTP Method, 기본 페이지, 프로토콜 버전
- Host: 사용자가 요청한 도메인 정보
- User-Agent: 사용자 웹 브라우저 종류 및 버전 정보

<br>

##### HTTP 요청 본문

- 사용자 이름 및 암호 또는 양식에 입력된 기타 데이터와 같이 웹서버에 제출되는 모든 정보 포함

---

##### HTTP 응답

- 웹 클라이언트가 HTTP 요청에 대한 응답으로 인터넷 서버에서 받는 것

- HTTP 요청에서 요청된 내용을 기반으로 중요한 정보를 전달

1. HTTP 상태 코드
2. HTTP 응답 헤더
3. (HTTP 본문)

<br>

##### HTTP 상태 코드

- HTTP 요청이 성공적으로 완료되었는지 여부를 나타내는 데 가장 자주 사용되는 3자리 코드
- 상태코드(xx는 00-99 사이의 다른 숫자)
  - 1xx: 정보
  - 2xx: 성공 ex) `200 OK`: 요청이 제대로 완료되었음
  - 3xx: 리디렉션
  - 4xx: 클라이언트 오류 ex) `400 Bad Request` / `404 NOT FOUND`
  - 5xx: 서버 오류

<br>

##### HTTP 응답 헤더

응답 본문에서 전송되는 데이터의 언어 및 형식과 같은 중요한 정보를 전달하는 헤더와 함께 전달

![image](https://user-images.githubusercontent.com/77482972/160686087-7db0797d-e494-4d34-8953-e38b4682d93b.png)

![image](https://user-images.githubusercontent.com/77482972/160678703-9be396b3-e8a4-436e-af17-a9e59386f0b9.png)

- Status Line: HTTP 버전, 상태코드
- Date, Server(서버의 버전 정보가 드러나므로 보안상 주의할 필요가 있다), Last Modified(수정할 필요가 있을 때만 수정하도록 돕는다), Content-Type

<br>

##### HTTP 응답 본문

클라이언트가 요청한 리소스 데이터

---

#### An Overview of HTTP

##### <HTTP 기반 시스템의 구성 요소>

클라이언트와 서버 사이에는 게이트웨이 또는 프록시라고 하는 수많은 엔티티가 존재

<br>

##### 클라이언트

- 브라우저는 요청을 시작하는 엔티티
- 먼저 페이지를 나타내는 html 문서를 가져오라는 요청을 보내고
- 파일을 구문 분석해 실행 스크립트, css 및 하위 리소스에 해당하는 추가 요청을 보낸다.
- 그 후, 웹 브라우저는 이러한 리소스를 결합해 웹 페이지를 제공
- 웹 페이지는 하이퍼텍스트 문서(마우스 클릭으로 링크 이동)
- 브라우저는 이러한 지시를 HTTP 요청으로 변환하고 응답을 추가로 해석해 사용자에게 응답을 제공

<br>

##### 웹 서버

- 클라이언트가 요청한대로 문서를 제공
- 요청시 문서의 전체 또는 부분을 생성

<br>

##### <HTTP 특성>

##### Connectionless

- 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질
- 서버가 다수의 클라이언트와 지속적으로 연결을 유지해야한다면 많은 리소스가 발생하기 때문
- 하지만, 동일 클라이언트의 모든 요청에 대해 매번 연결 시도/해제의 과정을 거쳐야하므로 오버헤드가 발생한다는 단점(→ KeepAlive)

<br>

##### Stateless

- Connectionless로 인해 서버는 클라이언트를 식별할 수 없다.
- 클라이언트를 기억하게 하는 방법으로 쿠키, 세션, 토큰 기반 인증방식 등이 있다.
  - 쿠키
    - 사용자 정보가 브라우저에 저장
    - 위변조 가능성이 높아 보안에 취약
  - 세션
    - 브라우저가 아닌 서버단에 사용자 정보를 저장
    - 서버 메모리 차지
    - 동시 접속자가 많을 경우 서버 과부하의 원인
    - 보안에 완벽하지는 않음(쿠키보다는 안전)
  - 토큰을 사용하는 OAuth, JWT 등
    - 쿠키와 세션의 문제점을 보완하기 위해 도입
    - 보호할 데이터를 토큰으로 치환해 원본 데이터 대신 토큰을 사용하는 기술
    - 토큰을 탈취당하더라도 데이터에 대한 정보를 알 수 없기 때문에 보안성이 높은 기술

<br>

##### HTTP 흐름

1. TCP 연결 열기

   - TCP 연결은 하나 이상의 요청을 보내고 응답을 받는데 사용된다.

2. HTTP 메세지 보내기

3. 서버에서 보낸 응답 읽기

4. 추가 요청을 위해 연결을 닫거나 재사용

<br>

---

#### Journey to HTTP/2

##### HTTP/0.9

- 최초의 문서화된 HTTP 버전(1991)

- GET이 유일한 메서드
- 응답은 HTML

<br>

##### HTTP/1.0

- HTML만이 가능했던 0.9와 달리 이미지, 비디오 파일, 일반 텍스트 또는 기타 콘텐츠 유형과 같은 다른 응답 형식도 처리 가능

- HTTP 헤더가 요청 및 응답 모두에 추가됨

- 더 많은 메소드가 추가

- 응답을 식별하는 상태 코드 추가

- Connection: Keep-Alive 추가 가능

- 문자 세트 지원 도입, 권한 부여, 캐싱, 콘텐츠 인코딩 등이 포함

- 연결당 여러 요청을 가질 수 없다는 단점

  > 10개 이미지, 5개 스타일시트, 5개 자바스크립트 파일이 있는 웹페이지를 방문하면 20 항목을 별도로 연결해야 한다는 문제가 있다
  >
  > 3-way handshaking

<br>

##### HTTP/1.1

- PUT, PATCH, OPTIONS, DELETE 메소드 추가
- Keep Alive가 기본
- 영구 연결 도입
  - 연결이 기본적으로 닫히지 않고 열린 상태로 유지되어 여러 순차 요청이 허용
  - 클라이언트는 일반적으로 마지막 요청에서 `Connection: close` 헤더를 보내 안전하게 연결을 닫음
- 파이프라이닝 추가

  - 클라이언트가 동일한 연결에 있는 서버의 응답을 기다리지 않고 서버에 여러 요청을 보낼 수 있음
  - 서버는 요청이 수신된 동일한 순서로 응답을 보냄
  - 순서 파악을 위해 `Content-length` 헤더를 이용해 응답이 끝나는 위치를 식별
  - ![image](https://user-images.githubusercontent.com/77482972/160754667-baa1ae50-70fd-42a3-808a-0041138ed724.png)

- 캐싱, 바이트 범위, 문자 집합, 언어 협상, 클라이언트 쿠키, 향상된 압축 지원, 새 상태코드 추가

<br>

##### HTTP/2

- 텍스트 대신 바이너리
  - 파싱이 더 빠름
  - 오류 발생 가능성이 낮다.
- 우선 순위 설정
  - 스트림별로 우선 순위를 지정
  - 중요한 리소스의 처리 지연을 방지
- 단일 연결을 통한 여러 비동기 HTTP 요청(멀티 플렉싱)
  - 하나의 요청이 지연되면 나머지 응답이 늦어지는 기존 파이프라이닝과는 달리 각각의 요청/응답을 독립적으로 처리
- HPACK을 사용한 헤더 압축
  - 연속된 요청에는 중복된 헤더 내용이 많다. 이를 압축하여 데이터 중복에 의한 전송 오버헤드를 줄였다.
  - 반복적으로 사용되는 헤더를 헤더 테이블 내의 인덱스로 표기
- 단일 요청에 대한 다중 응답(서버 푸시)
  - 클라이언트의 요청을 예상하여 클라이언트 캐쉬에 클라이언트가 요청할 것 같은 데이터를 넣어두는 기술
  - 클라이언트가 요청하지 않아도 필요가 예상되는 리소스를 서버가 미리 전송

<br>

##### HTTP/3

- UDP 기반(QUIC 프로토콜) 통신
- 지금 당장은 Draft 상태

---

##### HyperText

hyper + Text → 텍스트를 뛰어넘다 → 텍스트 정보에 대해 순차적 접근을 뛰어 넘는다

##### HTTP 기반 API

##### Keep Alive

연속된 요청에는 접속을 다시 이용

##### 프록시
